name: Cleanup of Stale Branches (Deletes if branch and commits are 2+ months old)

on:
  push:
    branches:
      - feature-final-branch  # 🔁 Replace with the branch you want to trigger on

permissions:
  contents: write
  pull-requests: write

jobs:
  cleanup:
    name: Cleanup Stale Branches in Multiple Repos
    runs-on: ubuntu-latest

    steps:
      - name: Ensure CLI tools are installed
        run: |
          command -v gh >/dev/null || (echo "❌ GitHub CLI (gh) is not installed" && exit 1)
          command -v jq >/dev/null || (echo "❌ jq is not installed" && exit 1)

      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      - name: Cleanup stale branches across repositories (Dry Run with Clean Output and Debug Split)
        run: |
          set -eo pipefail

          # Separate stdout (human-readable) and stderr (debug)
          exec 3>&1  # Save stdout
          exec 4>&2  # Save stderr

          DEBUG=true  # Toggle debug output

          if [ "$DEBUG" = true ]; then
            exec 1>&2  # Send stdout to stderr for debug output
            set -x
          fi

          repos=(
            "KudziDave/reusable-terraform-plan-apply"
            # Add more repositories here
          )

          for repo in "${repos[@]}"; do
            echo "" >&3
            echo "🔁 Processing $repo" >&3
            echo "=============================================" >&3

            {
              branches=$(gh api repos/$repo/branches --jq '.[].name')

              for branch in $branches; do
                if [[ "$branch" == "main" ]]; then
                  echo "⏭️ Skipping 'main'" >&3
                  continue
                fi

                allow_delete=$(gh api repos/$repo/branches/$branch/protection --silent 2>/dev/null | jq -r '.allow_deletions.enabled // "true"')
                if [[ "$allow_delete" == "false" ]]; then
                  echo "⏭️ Skipping protected branch: $branch" >&3
                  continue
                fi

                if gh api repos/$repo/git/ref/tags/do-not-prune/$branch --silent >/dev/null 2>&1; then
                  echo "🏷️ Skipping tagged branch: do-not-prune/$branch" >&3
                  continue
                fi

                last_commit_date=$(gh api repos/$repo/commits/$branch --jq '.commit.committer.date' || echo "")
                last_commit_timestamp=$(date -d "$last_commit_date" +%s 2>/dev/null || echo 0)
                two_months_ago_timestamp=$(date -d "2 months ago" +%s)

                if [[ "$last_commit_timestamp" -eq 0 || "$last_commit_timestamp" -ge "$two_months_ago_timestamp" ]]; then
                  echo "✅ Branch '$branch' is active or too recent." >&3
                  continue
                fi

                merge_base=$(gh api repos/$repo/compare/main...$branch --jq '.merge_base_commit.sha' || true)
                first_commit=$(gh api repos/$repo/commits/$branch --jq '.[].sha' --paginate | tail -n 1)
                if [[ -n "$first_commit" ]]; then
                  branch_creation_date=$(gh api repos/$repo/commits/$first_commit --jq '.commit.committer.date')
                  branch_creation_timestamp=$(date -d "$branch_creation_date" +%s)
                else
                  echo "⏭️ No unique commits found for $branch. Skipping." >&3
                  continue
                fi

                if [[ "$branch_creation_timestamp" -ge "$two_months_ago_timestamp" ]]; then
                  echo "⏭️ Branch '$branch' is too new." >&3
                  continue
                fi

                echo "🔥 Deleting stale branch: $branch" >&3
                echo "  ➤ Last commit: $last_commit_date" >&3
                echo "  ➤ Created on: $branch_creation_date" >&3
                echo "  ➤ (Dry run) Would delete branch: $branch" >&3
                # Actual deletion disabled for dry run
                # if ! gh api -X DELETE repos/$repo/git/refs/heads/$branch; then
                #   echo "⚠️ Failed to delete branch '$branch'. It may be protected." >&3
                # fi
              done

            } || {
              echo "❌ Failed to process $repo — skipping to next." >&3
              continue
            }

          done

          # Restore original stdout/stderr
          exec 1>&3
          exec 2>&4
