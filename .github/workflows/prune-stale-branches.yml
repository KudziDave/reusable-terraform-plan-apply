name: Cleanup of Stale Branches (Dry Run Only with Summary)

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Perform a dry run without deleting branches (true/false)'
        required: true
        default: 'true'
  push:
    branches:
      - feature-final-branch
  pull_request:
    branches:
      - feature-final-branch

jobs:
  cleanup:
    runs-on: ubuntu-latest

    steps:
      - name: Ensure CLI tools are installed
        run: |
          command -v gh >/dev/null || (echo "❌ GitHub CLI (gh) is not installed" && exit 1)
          command -v jq >/dev/null || (echo "❌ jq is not installed" && exit 1)

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup GitHub CLI
        run: |
          gh auth setup-git
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch protected branches
        id: protected
        run: |
          echo "Fetching protected branches..."
          gh api repos/${{ github.repository }}/branches \
            --jq '.[] | select(.protected == true) | .name' > protected-branches.txt
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Simulate stale branch cleanup (no deletion)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
        run: |
          set -e
          git fetch --all --prune --tags

          mapfile -t protected < protected-branches.txt
          protected_branches="${protected[*]}"

          echo "Protected branches: ${protected_branches[@]}"

          echo "| Branch | Status | Reason |"
          echo "|--------|--------|--------|"

          branches=$(git for-each-ref --format='%(refname:short)' refs/remotes/origin/ | sed 's|^origin/||')
          echo "All branches: $branches"

          for branch in $branches; do
            if [[ "$branch" == "origin" ]]; then
              continue  # Skip incorrect or malformed branch names
            fi

            reason=""
            status="⏸️ Skipped"

            echo ""
            echo "🔍 Checking branch: $branch"

            # Calculate last commit date
            last_commit_date=$(git log -1 --format=%aD origin/$branch)
            last_commit_timestamp=$(date -d "$last_commit_date" +%s)

            # Determine "creation date" by finding first unique commit after main divergence
            merge_base=$(git merge-base origin/main origin/$branch)
            first_unique_commit=$(git log origin/$branch --reverse --pretty=format:"%H" --not $merge_base | head -1)

            if [ -n "$first_unique_commit" ]; then
              branch_creation_date=$(git show -s --format=%aD $first_unique_commit)
            else
              branch_creation_date=$(git show -s --format=%aD $merge_base)
            fi

            branch_creation_timestamp=$(date -d "$branch_creation_date" +%s)
            three_months_ago_timestamp=$(date -d "3 months ago" +%s)

            echo "  ➤ Creation date: $branch_creation_date"
            echo "  ➤ Last commit date: $last_commit_date"

            if [ "$branch" == "main" ]; then
              reason="Main branch"
            elif echo "$protected_branches" | grep -qw "$branch"; then
              reason="Protected by GitHub rules"
            elif git show-ref --verify --quiet "refs/tags/do-not-prune/$branch"; then
              reason="Tagged do-not-prune"
            elif [[ $last_commit_timestamp -lt $three_months_ago_timestamp ]] && [[ $branch_creation_timestamp -lt $three_months_ago_timestamp ]]; then
              reason="Stale (no commits in 90d, older than 3 months)"
              status="🚫 Would delete"
            else
              reason="Active (recent commits)"
            fi

            printf "| \`%s\` | %s | %s |\n" "$branch" "$status" "$reason"
          done
